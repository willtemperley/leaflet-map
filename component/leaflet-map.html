<link rel="import" href="../polymer/polymer-element.html">
<script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"
        integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw=="
        crossorigin=""></script>

<link rel="import" href="leaflet-marker.html">
<link rel="import" href="leaflet-layer.html">
<link rel="import" href="leaflet-layer-group.html">
<link rel="import" href="leaflet-scale-control.html">
<link rel="import" href="leaflet-geojson.html">

<dom-module id="leaflet-map">
  <template>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css"
          integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ=="
          crossorigin=""/>
    <style>
      :host {
        display: block;
      }

      :host #map {
        height: 100%;
        width: 100%
      }

    </style>
    <div id="map">

    </div>
    <slot></slot>
  </template>

  <script>
    /**
     * `leaflet-map`
     * lmap
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class LeafletMap extends Polymer.Element {
      static get is() {
        return 'leaflet-map';
      }

      static get properties() {
        return {

          options: {
            type: Object,
            value: null
          },

          opts: {
            type: String,
            value: null,
            observer: '_optsObserver'
          },

          mapState: {
            type: String,
          }

        };
      }


      _registerMapOnChildren() {

        for (let i = 0; i < this.children.length; i++) {
          let m = this.children[i];
          m.container = this.map;
        }

        // this._fitToMarkers();
      }

      _optsObserver() {
        if (this.opts && this.container) {
          let options = JSON.parse(this.opts);
          this._create(options);
        }
      }

      _create(options) {
        // super.connectedCallback();

        LeafletMap.guessLeafletImagePath();
        this.map = L.map(this.$.map, options);

        this._mapInitialized = false;

        // fire an event for when this.map is defined and ready.
        // (needed for components that talk to this.map directly)
        this.dispatchEvent(new CustomEvent('map-ready'));

        // update attributes
        this.map.on('moveend zoomend dragend', function (e) {
          this._updateMapState();
        }, this);

        // forward events
        this.map.on('click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu focus blur preclick load unload viewreset movestart move moveend dragstart drag dragend zoomstart zoomend zoomlevelschange resize autopanstart layeradd layerremove baselayerchange overlayadd overlayremove locationfound locationerror popupopen popupclose', function (e) {
          this.dispatchEvent(new CustomEvent(e.type, e));
        }, this);

        // set map view after registering events so viewreset and load events can be caught
        this.map.setView([this.latitude, this.longitude], this.zoom);

        if (this.zoom === -1) {
          this.map.fitWorld();
        }

        // add a default layer if there are no layers defined
        let defaultLayerRequired = true;
        for (let i = 0; i < this.children.length; i++) {
          const e = this.children[i];
          if (e.isLayer && e.isLayer()) {
            defaultLayerRequired = false;
          }
        }
        if (defaultLayerRequired) {
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery &copy; <a href="http://mapbox.com">Mapbox</a>',
            maxZoom: 18
          }).addTo(this.map);
        }

        this._registerMapOnChildren();
        this._mutationObserver = new MutationObserver(this._registerMapOnChildren.bind(this));
        this._mutationObserver.observe(this, {childList: true});
      }


      static guessLeafletImagePath() {
        if (L.Icon.Default.imagePath) {
          return;
        }

        let scripts = document.getElementsByTagName('link'),
          leafletRe = /[\/^]leaflet-map.html$/;

        let i, len, src, matches, path;

        for (i = 0, len = scripts.length; i < len; i++) {
          src = scripts[i].href;
          matches = src.match(leafletRe);

          if (matches) {
            path = src.split(leafletRe)[0];
            L.Icon.Default.imagePath = (path ? path + '/' : '') + '../leaflet/dist/images';
          }
        }
      }


      detached() {
        this._mutationObserver.disconnect();
      }

      _viewChanged(newValue, oldValue) {
        if (this.map) {

          this.map.setView(L.latLng(this.latitude, this.longitude), this.zoom);

          /*
          The map is never happy until it's secure about it's size
          Being explicit about the element size is the safest, but not always possible
          hence a one-time call to ask the map to rethink it's body image
          */
          if (!this._mapInitialized) {
            this.map.invalidateSize();
            this._mapInitialized = true;
          }
        }
      }

      _fitToMarkers() {
        if (this.map && this.fitToMarkers) {
          let bounds = [];
          let i = 0, f;
          for (; f = this.children[i]; i++) {
            if (f.latitude && f.longitude) {
              bounds.push([f.latitude, f.longitude]);
            }
          }
          if (bounds.length > 0) {
            this.map.fitBounds(bounds);
            this.map.invalidateSize();
          }
        }
      }

      /**
       * Returns a GeoJSON including all the features of the map
       *
       * @method toGeoJSON
       */
      toGeoJSON() {
        let geoJSON = {
          "type": "FeatureCollection",
          "features": []
        };

        let i = 0, f;
        for (; f = this.features[i]; i++) {
          geoJSON.features.push(f.feature.toGeoJSON());
        }
        return geoJSON;
      }

      /**
       */
      _updateMapState() {
        console.log(this.map.getZoom());
        this.mapState = JSON.stringify(
          {
            x: this.map.getCenter().lng,
            y: this.map.getCenter().lat,
            z: this.map.getZoom()
          }
        );
      }

    }

    window.customElements.define(LeafletMap.is, LeafletMap);
  </script>
</dom-module>
